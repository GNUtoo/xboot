/*
 * kernel/graphic/render.c
 *
 * Copyright(c) 2007-2019 Jianjun Jiang <8192542@qq.com>
 * Official site: http://xboot.org
 * Mobile phone: +86-18665388956
 * QQ: 8192542
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

#include <xboot.h>
#include <graphic/surface.h>

void * render_default_create(struct surface_t * s)
{
	return NULL;
}

void render_default_destroy(void * pctx)
{
}

static inline void blend(uint32_t * d, uint32_t * s)
{
	uint32_t dv, sv = *s;
	uint8_t da, dr, dg, db;
	uint8_t sa, sr, sg, sb;
	uint8_t a, r, g, b;
	int t;

	sa = (sv >> 24) & 0xff;
	if(sa == 255)
	{
		*d = sv;
	}
	else if(sa != 0)
	{
		sr = (sv >> 16) & 0xff;
		sg = (sv >> 8) & 0xff;
		sb = (sv >> 0) & 0xff;
		dv = *d;
		da = (dv >> 24) & 0xff;
		dr = (dv >> 16) & 0xff;
		dg = (dv >> 8) & 0xff;
		db = (dv >> 0) & 0xff;
		t = sa + (sa >> 8);
		a = (((sa + da) << 8) - da * t) >> 8;
		r = (((sr + dr) << 8) - dr * t) >> 8;
		g = (((sg + dg) << 8) - dg * t) >> 8;
		b = (((sb + db) << 8) - db * t) >> 8;
		*d = (a << 24) | (r << 16) | (g << 8) | (b << 0);
	}
}

void render_default_blit(struct surface_t * s, struct region_t * clip, struct matrix_t * m, struct surface_t * src, enum render_type_t type)
{
	struct region_t r, region;
	struct matrix_t t;
	uint32_t * p;
	uint32_t * dp = surface_get_pixels(s);
	uint32_t * sp = surface_get_pixels(src);
	int ds = surface_get_stride(s) >> 2;
	int ss = surface_get_stride(src) >> 2;
	int sw = surface_get_width(src);
	int sh = surface_get_height(src);
	int x1, y1, x2, y2, stride;
	int x, y, ox, oy;
	double fx, fy, ofx, ofy;

	region_init(&r, 0, 0, surface_get_width(s), surface_get_height(s));
	if(clip)
	{
		if(!region_intersect(&r, &r, clip))
			return;
	}
	matrix_transform_region(m, sw, sh, &region);
	if(!region_intersect(&r, &r, &region))
		return;

	x1 = r.x;
	y1 = r.y;
	x2 = r.x + r.w;
	y2 = r.y + r.h;
	stride = ds - r.w;
	p = dp + y1 * ds + x1;
	fx = x1;
	fy = y1;
	memcpy(&t, m, sizeof(struct matrix_t));
	matrix_invert(&t);
	matrix_transform_point(&t, &fx, &fy);

	for(y = y1; y < y2; ++y, fx += t.c, fy += t.d)
	{
		ofx = fx;
		ofy = fy;
		for(x = x1; x < x2; ++x, ofx += t.a, ofy += t.b)
		{
			ox = (int)ofx;
			oy = (int)ofy;
			if(ox >= 0 && ox < sw && oy >= 0 && oy < sh)
			{
				blend(p, sp + oy * ss + ox);
			}
			p++;
		}
		p += stride;
	}
}

void render_default_fill(struct surface_t * s, struct region_t * clip, struct matrix_t * m, int w, int h, struct color_t * c, enum render_type_t type)
{
	struct region_t r, region;
	struct matrix_t t;
	uint32_t * p, v;
	int ds = surface_get_stride(s) >> 2;
	int x1, y1, x2, y2, stride;
	int x, y, ox, oy;
	double fx, fy, ofx, ofy;

	region_init(&r, 0, 0, surface_get_width(s), surface_get_height(s));
	if(clip)
	{
		if(!region_intersect(&r, &r, clip))
			return;
	}
	matrix_transform_region(m, w, h, &region);
	if(!region_intersect(&r, &r, &region))
		return;

	x1 = r.x;
	y1 = r.y;
	x2 = r.x + r.w;
	y2 = r.y + r.h;
	stride = ds - r.w;
	p = (uint32_t *)surface_get_pixels(s) + y1 * ds + x1;
	v = color_get_premult(c);
	fx = x1;
	fy = y1;
	memcpy(&t, m, sizeof(struct matrix_t));
	matrix_invert(&t);
	matrix_transform_point(&t, &fx, &fy);

	for(y = y1; y < y2; ++y, fx += t.c, fy += t.d)
	{
		ofx = fx;
		ofy = fy;
		for(x = x1; x < x2; ++x, ofx += t.a, ofy += t.b)
		{
			ox = (int)ofx;
			oy = (int)ofy;
			if(ox >= 0 && ox < w && oy >= 0 && oy < h)
				*p = v;
			p++;
		}
		p += stride;
	}
}

static inline void shape_set_pixel(struct surface_t * s, int x, int y, uint32_t v)
{
	uint32_t * p = (uint32_t *)s->pixels + y * (s->stride >> 2) + x;
	*p = v;
}

static inline void shape_hline(struct surface_t * s, int x0, int y0, int x, uint32_t v)
{
	uint32_t * p = (uint32_t *)s->pixels + y0 * (s->stride >> 2) + x0;
	int i;
	for(i = 0; i < x; i++)
		*p++ = v;
}

static inline void shape_line(struct surface_t * s, int x0, int y0, int x1, int y1, uint32_t v)
{
	int dx = x1 - x0;
	int dy = y1 - y0;
	int stepx, stepy;
	int fraction;

	if(dy == 0)
	{
		if(dx > 0)
		{
			shape_hline(s, x0, y0, dx, v);
		}
		else if(dx < 0)
		{
			shape_hline(s, x1, y0, -dx, v);
		}
	}
	else
	{
		if(dy < 0)
		{
			dy = -dy;
			stepy = -1;
		}
		else
		{
			stepy = 1;
		}
		if(dx < 0)
		{
			dx = -dx;
			stepx = -1;
		}
		else
		{
			stepx = 1;
		}
		dy <<= 1;
		dx <<= 1;
		shape_set_pixel(s, x0, y0, v);
		if(dx > dy)
		{
			fraction = dy - (dx >> 1);
			while(x0 != x1)
			{
				if(fraction >= 0)
				{
					y0 += stepy;
					fraction -= dx;
				}
				x0 += stepx;
				fraction += dy;
				shape_set_pixel(s, x0, y0, v);
			}
		}
		else
		{
			fraction = dx - (dy >> 1);
			while(y0 != y1)
			{
				if(fraction >= 0)
				{
					x0 += stepx;
					fraction -= dy;
				}
				y0 += stepy;
				fraction += dx;
				shape_set_pixel(s, x0, y0, v);
			}
		}
	}
}

void render_default_shape_line(struct surface_t * s, struct region_t * clip, struct point_t * p0, struct point_t * p1, int thickness, struct color_t * c)
{
	struct region_t r;
	int x0, y0, x1, y1;

	region_init(&r, 0, 0, surface_get_width(s), surface_get_height(s));
	if(clip)
	{
		if(!region_intersect(&r, &r, clip))
			return;
	}
	x0 = p0->x;
	y0 = p0->y;
	x1 = p1->x;
	y1 = p1->y;
	if(region_clip_line(&r, &x0, &y0, &x1, &y1))
		shape_line(s, x0, y0, x1, y1, color_get_premult(c));
}

void render_default_shape_polyline(struct surface_t * s, struct region_t * clip, struct point_t * p, int n, int thickness, struct color_t * c)
{
}

void render_default_shape_curve(struct surface_t * s, struct region_t * clip, struct point_t * p, int n, int thickness, struct color_t * c)
{
}

void render_default_shape_triangle(struct surface_t * s, struct region_t * clip, struct point_t * p0, struct point_t * p1, struct point_t * p2, int thickness, struct color_t * c)
{
}

void render_default_shape_rectangle(struct surface_t * s, struct region_t * clip, int x, int y, int w, int h, int radius, int thickness, struct color_t * c)
{
}

void render_default_shape_polygon(struct surface_t * s, struct region_t * clip, struct point_t * p, int n, int thickness, struct color_t * c)
{
}

void render_default_shape_circle(struct surface_t * s, struct region_t * clip, int x, int y, int radius, int thickness, struct color_t * c)
{
}

void render_default_shape_ellipse(struct surface_t * s, struct region_t * clip, int x, int y, int w, int h, int thickness, struct color_t * c)
{
}

void render_default_shape_arc(struct surface_t * s, struct region_t * clip, int x, int y, int radius, int a1, int a2, int thickness, struct color_t * c)
{
}

void render_default_filter_haldclut(struct surface_t * s, struct surface_t * clut, const char * type)
{
	int width = surface_get_width(s);
	int height = surface_get_height(s);
	int stride = surface_get_stride(s);
	unsigned char * p, * q = surface_get_pixels(s);
	int cw = surface_get_width(clut);
	int ch = surface_get_height(clut);
	unsigned char * t, * cp, * cq = surface_get_pixels(clut);
	double sum[9];
	double dr, dg, db, xdr, xdg, xdb;
	int ri, gi, bi;
	int x, y, v;
	int level, level2, level_1, level_2;

	if(cw == ch)
	{
		switch(cw)
		{
		case 8:    level =  2 *  2; break;
		case 27:   level =  3 *  3; break;
		case 64:   level =  4 *  4; break;
		case 125:  level =  5 *  5; break;
		case 216:  level =  6 *  6; break;
		case 343:  level =  7 *  7; break;
		case 512:  level =  8 *  8; break;
		case 729:  level =  9 *  9; break;
		case 1000: level = 10 * 10; break;
		case 1331: level = 11 * 11; break;
		case 1728: level = 12 * 12; break;
		case 2197: level = 13 * 13; break;
		case 2744: level = 14 * 14; break;
		case 3375: level = 15 * 15; break;
		case 4096: level = 16 * 16; break;
		default:
			return;
		}
		level2 = level * level;
		level_1 = level - 1;
		level_2 = level - 2;
		switch(shash(type))
		{
		case 0x09fa48d7: /* "nearest" */
			for(y = 0; y < height; y++, q += stride)
			{
				for(x = 0, p = q; x < width; x++, p += 4)
				{
					if(p[3] != 0)
					{
						if(p[3] == 255)
						{
							bi = p[0] * level_1 / 255;
							if(bi > level_2)
								bi = level_2;
							gi = p[1] * level_1 / 255;
							if(gi > level_2)
								gi = level_2;
							ri = p[2] * level_1 / 255;
							if(ri > level_2)
								ri = level_2;
							cp = cq + ((bi * level2 + gi * level + ri) << 2);
							p[0] = cp[0];
							p[1] = cp[1];
							p[2] = cp[2];
						}
						else
						{
							bi = p[0] * level_1 / p[3];
							if(bi > level_2)
								bi = level_2;
							gi = p[1] * level_1 / p[3];
							if(gi > level_2)
								gi = level_2;
							ri = p[2] * level_1 / p[3];
							if(ri > level_2)
								ri = level_2;
							cp = cq + ((bi * level2 + gi * level + ri) << 2);
							p[0] = cp[0] * p[3] / 255;
							p[1] = cp[1] * p[3] / 255;
							p[2] = cp[2] * p[3] / 255;
						}
					}
				}
			}
			break;
		case 0x860ab38f: /* "trilinear" */
			for(y = 0; y < height; y++, q += stride)
			{
				for(x = 0, p = q; x < width; x++, p += 4)
				{
					if(p[3] != 0)
					{
						if(p[3] == 255)
						{
							bi = p[0] * level_1 / 255;
							if(bi > level_2)
								bi = level_2;
							gi = p[1] * level_1 / 255;
							if(gi > level_2)
								gi = level_2;
							ri = p[2] * level_1 / 255;
							if(ri > level_2)
								ri = level_2;
							db = (double)p[0] * level_1 / 255 - bi;
							dg = (double)p[1] * level_1 / 255 - gi;
							dr = (double)p[2] * level_1 / 255 - ri;
							xdb = 1 - db;
							xdg = 1 - dg;
							xdr = 1 - dr;
							cp = cq + ((bi * level2 + gi * level + ri) << 2);
							t = cp;
							sum[0] = (double)t[0] * xdr;
							sum[1] = (double)t[1] * xdr;
							sum[2] = (double)t[2] * xdr;
							t += 4;
							sum[0] += (double)t[0] * dr;
							sum[1] += (double)t[1] * dr;
							sum[2] += (double)t[2] * dr;
							t = cp + (level << 2);
							sum[3] = (double)t[0] * xdr;
							sum[4] = (double)t[1] * xdr;
							sum[5] = (double)t[2] * xdr;
							t += 4;
							sum[3] += (double)t[0] * dr;
							sum[4] += (double)t[1] * dr;
							sum[5] += (double)t[2] * dr;
							sum[6] = sum[0] * xdg + sum[3] * dg;
							sum[7] = sum[1] * xdg + sum[4] * dg;
							sum[8] = sum[2] * xdg + sum[5] * dg;
							t = cp + (level2 << 2);
							sum[0] = (double)t[0] * xdr;
							sum[1] = (double)t[1] * xdr;
							sum[2] = (double)t[2] * xdr;
							t += 4;
							sum[0] += (double)t[0] * dr;
							sum[1] += (double)t[1] * dr;
							sum[2] += (double)t[2] * dr;
							t = cp + ((level2 + level) << 2);
							sum[3] = (double)t[0] * xdr;
							sum[4] = (double)t[1] * xdr;
							sum[5] = (double)t[2] * xdr;
							t += 4;
							sum[3] += (double)t[0] * dr;
							sum[4] += (double)t[1] * dr;
							sum[5] += (double)t[2] * dr;
							sum[0] = sum[0] * xdg + sum[3] * dg;
							sum[1] = sum[1] * xdg + sum[4] * dg;
							sum[2] = sum[2] * xdg + sum[5] * dg;
							v = sum[6] * xdb + sum[0] * db;
							p[0] = clamp(v, 0, 255);
							v = sum[7] * xdb + sum[1] * db;
							p[1] = clamp(v, 0, 255);
							v = sum[8] * xdb + sum[2] * db;
							p[2] = clamp(v, 0, 255);
						}
						else
						{
							bi = p[0] * level_1 / p[3];
							if(bi > level_2)
								bi = level_2;
							gi = p[1] * level_1 / p[3];
							if(gi > level_2)
								gi = level_2;
							ri = p[2] * level_1 / p[3];
							if(ri > level_2)
								ri = level_2;
							db = (double)p[0] * level_1 / p[3] - bi;
							dg = (double)p[1] * level_1 / p[3] - gi;
							dr = (double)p[2] * level_1 / p[3] - ri;
							xdb = 1 - db;
							xdg = 1 - dg;
							xdr = 1 - dr;
							cp = cq + ((bi * level2 + gi * level + ri) << 2);
							t = cp;
							sum[0] = (double)t[0] * xdr;
							sum[1] = (double)t[1] * xdr;
							sum[2] = (double)t[2] * xdr;
							t += 4;
							sum[0] += (double)t[0] * dr;
							sum[1] += (double)t[1] * dr;
							sum[2] += (double)t[2] * dr;
							t = cp + (level << 2);
							sum[3] = (double)t[0] * xdr;
							sum[4] = (double)t[1] * xdr;
							sum[5] = (double)t[2] * xdr;
							t += 4;
							sum[3] += (double)t[0] * dr;
							sum[4] += (double)t[1] * dr;
							sum[5] += (double)t[2] * dr;
							sum[6] = sum[0] * xdg + sum[3] * dg;
							sum[7] = sum[1] * xdg + sum[4] * dg;
							sum[8] = sum[2] * xdg + sum[5] * dg;
							t = cp + (level2 << 2);
							sum[0] = (double)t[0] * xdr;
							sum[1] = (double)t[1] * xdr;
							sum[2] = (double)t[2] * xdr;
							t += 4;
							sum[0] += (double)t[0] * dr;
							sum[1] += (double)t[1] * dr;
							sum[2] += (double)t[2] * dr;
							t = cp + ((level2 + level) << 2);
							sum[3] = (double)t[0] * xdr;
							sum[4] = (double)t[1] * xdr;
							sum[5] = (double)t[2] * xdr;
							t += 4;
							sum[3] += (double)t[0] * dr;
							sum[4] += (double)t[1] * dr;
							sum[5] += (double)t[2] * dr;
							sum[0] = sum[0] * xdg + sum[3] * dg;
							sum[1] = sum[1] * xdg + sum[4] * dg;
							sum[2] = sum[2] * xdg + sum[5] * dg;
							v = (sum[6] * xdb + sum[0] * db) * p[3] / 255;
							p[0] = clamp(v, 0, 255);
							v = (sum[7] * xdb + sum[1] * db) * p[3] / 255;
							p[1] = clamp(v, 0, 255);
							v = (sum[8] * xdb + sum[2] * db) * p[3] / 255;
							p[2] = clamp(v, 0, 255);
						}
					}
				}
			}
			break;
		default:
			break;
		}
	}
}

void render_default_filter_grayscale(struct surface_t * s)
{
	int width = surface_get_width(s);
	int height = surface_get_height(s);
	int stride = surface_get_stride(s);
	unsigned char * p, * q = surface_get_pixels(s);
	unsigned char r, g, b;
	unsigned char gray;
	int x, y;

	for(y = 0; y < height; y++, q += stride)
	{
		for(x = 0, p = q; x < width; x++, p += 4)
		{
			if(p[3] != 0)
			{
				if(p[3] == 255)
				{
					gray = (p[2] * 19595L + p[1] * 38469L + p[0] * 7472L) >> 16;
					p[0] = gray;
					p[1] = gray;
					p[2] = gray;
				}
				else
				{
					b = p[0] * 255 / p[3];
					g = p[1] * 255 / p[3];
					r = p[2] * 255 / p[3];
					gray = ((r * 19595L + g * 38469L + b * 7472L) >> 16) * p[3] / 255;
					p[0] = gray;
					p[1] = gray;
					p[2] = gray;
				}
			}
		}
	}
}

void render_default_filter_sepia(struct surface_t * s)
{
	int width = surface_get_width(s);
	int height = surface_get_height(s);
	int stride = surface_get_stride(s);
	unsigned char * p, * q = surface_get_pixels(s);
	unsigned char r, g, b;
	int tr, tg, tb;
	int x, y;

	for(y = 0; y < height; y++, q += stride)
	{
		for(x = 0, p = q; x < width; x++, p += 4)
		{
			if(p[3] != 0)
			{
				if(p[3] == 255)
				{
					tb = (p[2] * 17826L + p[1] * 34996L + p[0] * 8585L) >> 16;
					tg = (p[2] * 22872L + p[1] * 44958L + p[0] * 11010L) >> 16;
					tr = (p[2] * 25756L + p[1] * 50397L + p[0] * 12386L) >> 16;
					p[0] = min(tb, 255);
					p[1] = min(tg, 255);
					p[2] = min(tr, 255);
				}
				else
				{
					b = p[0] * 255 / p[3];
					g = p[1] * 255 / p[3];
					r = p[2] * 255 / p[3];
					tb = ((r * 17826L + g * 34996L + b * 8585L) >> 16) * p[3] / 255;
					tg = ((r * 22872L + g * 44958L + b * 11010L) >> 16) * p[3] / 255;
					tr = ((r * 25756L + g * 50397L + b * 12386L) >> 16) * p[3] / 255;
					p[0] = min(tb, 255);
					p[1] = min(tg, 255);
					p[2] = min(tr, 255);
				}
			}
		}
	}
}

void render_default_filter_invert(struct surface_t * s)
{
	int width = surface_get_width(s);
	int height = surface_get_height(s);
	int stride = surface_get_stride(s);
	unsigned char * p, * q = surface_get_pixels(s);
	int x, y;
	for(y = 0; y < height; y++, q += stride)
	{
		for(x = 0, p = q; x < width; x++, p += 4)
		{
			if(p[3] != 0)
			{
				p[0] = p[3] - p[0];
				p[1] = p[3] - p[1];
				p[2] = p[3] - p[2];
			}
		}
	}
}

void render_default_filter_threshold(struct surface_t * s, const char * type, int threshold, int value)
{
	int width = surface_get_width(s);
	int height = surface_get_height(s);
	int stride = surface_get_stride(s);
	unsigned char * p, * q = surface_get_pixels(s);
	int x, y;
	threshold = clamp(threshold, 0, 255);
	value = clamp(value, 0, 255);

	switch(shash(type))
	{
	case 0xf4229cca: /* "binary" */
		for(y = 0; y < height; y++, q += stride)
		{
			for(x = 0, p = q; x < width; x++, p += 4)
			{
				if(p[3] != 0)
				{
					if(p[3] == 255)
						p[2] = p[1] = p[0] = (p[0] > threshold) ? value : 0;
					else
						p[2] = p[1] = p[0] = (p[0] * 255 / p[3] > threshold) ? value * p[3] / 255 : 0;
				}
			}
		}
		break;
	case 0xc880666f: /* "binary-invert" */
		for(y = 0; y < height; y++, q += stride)
		{
			for(x = 0, p = q; x < width; x++, p += 4)
			{
				if(p[3] != 0)
				{
					if(p[3] == 255)
						p[2] = p[1] = p[0] = (p[0] > threshold) ? 0: value;
					else
						p[2] = p[1] = p[0] = (p[0] * 255 / p[3] > threshold) ? 0: value * p[3] / 255;
				}
			}
		}
		break;
	case 0x1e92b0a8: /* "tozero" */
		for(y = 0; y < height; y++, q += stride)
		{
			for(x = 0, p = q; x < width; x++, p += 4)
			{
				if(p[3] != 0)
				{
					if(p[3] == 255)
						p[2] = p[1] = p[0] = (p[0] > threshold) ? p[0] : 0;
					else
						p[2] = p[1] = p[0] = (p[0] * 255 / p[3] > threshold) ? p[0] * p[3] / 255 : 0;
				}
			}
		}
		break;
	case 0x98d3b48d: /* "tozero-invert" */
		for(y = 0; y < height; y++, q += stride)
		{
			for(x = 0, p = q; x < width; x++, p += 4)
			{
				if(p[3] != 0)
				{
					if(p[3] == 255)
						p[2] = p[1] = p[0] = (p[0] > threshold) ? 0 : p[0];
					else
						p[2] = p[1] = p[0] = (p[0] * 255 / p[3] > threshold) ? 0 : p[0] * p[3] / 255;
				}
			}
		}
		break;
	case 0x10729e11: /* "trunc" */
		for(y = 0; y < height; y++, q += stride)
		{
			for(x = 0, p = q; x < width; x++, p += 4)
			{
				if(p[3] != 0)
				{
					if(p[3] == 255)
						p[2] = p[1] = p[0] = (p[0] > threshold) ? threshold : value;
					else
						p[2] = p[1] = p[0] = (p[0] * 255 / p[3] > threshold) ? threshold * p[3] / 255 : value * p[3] / 255;
				}
			}
		}
		break;
	default:
		break;
	}
}

static const unsigned char colormap_parula[256][3] = {
	{ 0x44, 0x08, 0x9d }, { 0x43, 0x0c, 0x9e }, { 0x42, 0x0f, 0x9f }, { 0x42, 0x12, 0xa0 }, { 0x41, 0x15, 0xa1 }, { 0x40, 0x17, 0xa2 }, { 0x40, 0x1a, 0xa2 }, { 0x3f, 0x1c, 0xa3 },
	{ 0x3e, 0x1f, 0xa3 }, { 0x3d, 0x21, 0xa3 }, { 0x3c, 0x23, 0xa4 }, { 0x3b, 0x25, 0xa4 }, { 0x3a, 0x28, 0xa4 }, { 0x39, 0x2a, 0xa4 }, { 0x38, 0x2c, 0xa4 }, { 0x37, 0x2e, 0xa3 },
	{ 0x35, 0x30, 0xa3 }, { 0x34, 0x32, 0xa3 }, { 0x33, 0x34, 0xa2 }, { 0x32, 0x35, 0xa2 }, { 0x31, 0x37, 0xa1 }, { 0x30, 0x39, 0xa0 }, { 0x2f, 0x3b, 0x9f }, { 0x2d, 0x3c, 0x9f },
	{ 0x2c, 0x3e, 0x9e }, { 0x2b, 0x3f, 0x9d }, { 0x2a, 0x41, 0x9c }, { 0x29, 0x42, 0x9b }, { 0x29, 0x44, 0x9a }, { 0x28, 0x45, 0x99 }, { 0x27, 0x47, 0x98 }, { 0x26, 0x48, 0x97 },
	{ 0x26, 0x49, 0x96 }, { 0x25, 0x4a, 0x95 }, { 0x25, 0x4c, 0x94 }, { 0x24, 0x4d, 0x94 }, { 0x24, 0x4e, 0x93 }, { 0x24, 0x4f, 0x92 }, { 0x23, 0x50, 0x91 }, { 0x23, 0x51, 0x90 },
	{ 0x23, 0x52, 0x8f }, { 0x23, 0x53, 0x8e }, { 0x23, 0x54, 0x8e }, { 0x23, 0x55, 0x8d }, { 0x23, 0x56, 0x8c }, { 0x23, 0x57, 0x8b }, { 0x23, 0x58, 0x8b }, { 0x23, 0x59, 0x8a },
	{ 0x24, 0x5a, 0x89 }, { 0x24, 0x5b, 0x89 }, { 0x24, 0x5c, 0x88 }, { 0x25, 0x5d, 0x88 }, { 0x25, 0x5e, 0x87 }, { 0x25, 0x5f, 0x86 }, { 0x26, 0x60, 0x86 }, { 0x26, 0x61, 0x85 },
	{ 0x26, 0x61, 0x85 }, { 0x27, 0x62, 0x84 }, { 0x27, 0x63, 0x84 }, { 0x28, 0x64, 0x83 }, { 0x28, 0x65, 0x83 }, { 0x29, 0x66, 0x83 }, { 0x29, 0x66, 0x82 }, { 0x2a, 0x67, 0x82 },
	{ 0x2a, 0x68, 0x81 }, { 0x2b, 0x69, 0x81 }, { 0x2b, 0x6a, 0x81 }, { 0x2b, 0x6b, 0x80 }, { 0x2c, 0x6b, 0x80 }, { 0x2c, 0x6c, 0x80 }, { 0x2d, 0x6d, 0x80 }, { 0x2d, 0x6e, 0x7f },
	{ 0x2d, 0x6f, 0x7f }, { 0x2e, 0x70, 0x7f }, { 0x2e, 0x70, 0x7e }, { 0x2e, 0x71, 0x7e }, { 0x2f, 0x72, 0x7e }, { 0x2f, 0x73, 0x7e }, { 0x2f, 0x74, 0x7d }, { 0x30, 0x75, 0x7d },
	{ 0x30, 0x75, 0x7d }, { 0x30, 0x76, 0x7d }, { 0x30, 0x77, 0x7d }, { 0x30, 0x78, 0x7c }, { 0x30, 0x79, 0x7c }, { 0x31, 0x7a, 0x7c }, { 0x31, 0x7a, 0x7c }, { 0x31, 0x7b, 0x7b },
	{ 0x31, 0x7c, 0x7b }, { 0x31, 0x7d, 0x7b }, { 0x31, 0x7e, 0x7b }, { 0x31, 0x7f, 0x7a }, { 0x31, 0x80, 0x7a }, { 0x31, 0x81, 0x7a }, { 0x31, 0x81, 0x79 }, { 0x30, 0x82, 0x79 },
	{ 0x30, 0x83, 0x79 }, { 0x30, 0x84, 0x79 }, { 0x30, 0x85, 0x78 }, { 0x30, 0x86, 0x78 }, { 0x30, 0x87, 0x77 }, { 0x2f, 0x88, 0x77 }, { 0x2f, 0x89, 0x77 }, { 0x2f, 0x89, 0x76 },
	{ 0x2f, 0x8a, 0x76 }, { 0x2e, 0x8b, 0x75 }, { 0x2e, 0x8c, 0x75 }, { 0x2e, 0x8d, 0x74 }, { 0x2d, 0x8e, 0x74 }, { 0x2d, 0x8f, 0x73 }, { 0x2d, 0x90, 0x73 }, { 0x2c, 0x91, 0x72 },
	{ 0x2c, 0x92, 0x72 }, { 0x2c, 0x93, 0x71 }, { 0x2b, 0x94, 0x70 }, { 0x2b, 0x95, 0x70 }, { 0x2b, 0x95, 0x6f }, { 0x2b, 0x96, 0x6e }, { 0x2a, 0x97, 0x6d }, { 0x2a, 0x98, 0x6d },
	{ 0x2a, 0x99, 0x6c }, { 0x2a, 0x9a, 0x6b }, { 0x29, 0x9b, 0x6a }, { 0x29, 0x9c, 0x69 }, { 0x29, 0x9d, 0x68 }, { 0x29, 0x9e, 0x67 }, { 0x29, 0x9f, 0x66 }, { 0x29, 0xa0, 0x65 },
	{ 0x29, 0xa1, 0x64 }, { 0x2a, 0xa1, 0x63 }, { 0x2a, 0xa2, 0x62 }, { 0x2a, 0xa3, 0x61 }, { 0x2b, 0xa4, 0x60 }, { 0x2b, 0xa5, 0x5e }, { 0x2c, 0xa6, 0x5d }, { 0x2c, 0xa7, 0x5c },
	{ 0x2d, 0xa8, 0x5a }, { 0x2e, 0xa8, 0x59 }, { 0x2f, 0xa9, 0x58 }, { 0x30, 0xaa, 0x56 }, { 0x31, 0xab, 0x55 }, { 0x33, 0xac, 0x53 }, { 0x34, 0xad, 0x52 }, { 0x35, 0xad, 0x50 },
	{ 0x37, 0xae, 0x4e }, { 0x39, 0xaf, 0x4d }, { 0x3b, 0xb0, 0x4b }, { 0x3c, 0xb1, 0x49 }, { 0x3e, 0xb1, 0x47 }, { 0x41, 0xb2, 0x46 }, { 0x43, 0xb3, 0x44 }, { 0x45, 0xb3, 0x42 },
	{ 0x48, 0xb4, 0x40 }, { 0x4a, 0xb5, 0x3e }, { 0x4d, 0xb5, 0x3c }, { 0x4f, 0xb6, 0x3a }, { 0x52, 0xb6, 0x37 }, { 0x55, 0xb7, 0x35 }, { 0x58, 0xb7, 0x33 }, { 0x5b, 0xb8, 0x31 },
	{ 0x5e, 0xb8, 0x2f }, { 0x61, 0xb9, 0x2d }, { 0x64, 0xb9, 0x2b }, { 0x67, 0xba, 0x29 }, { 0x6b, 0xba, 0x27 }, { 0x6e, 0xba, 0x25 }, { 0x71, 0xbb, 0x23 }, { 0x74, 0xbb, 0x22 },
	{ 0x77, 0xbb, 0x20 }, { 0x7b, 0xbc, 0x1f }, { 0x7e, 0xbc, 0x1e }, { 0x81, 0xbc, 0x1d }, { 0x84, 0xbc, 0x1c }, { 0x87, 0xbd, 0x1c }, { 0x8a, 0xbd, 0x1b }, { 0x8d, 0xbd, 0x1b },
	{ 0x90, 0xbd, 0x1b }, { 0x93, 0xbd, 0x1b }, { 0x95, 0xbe, 0x1c }, { 0x98, 0xbe, 0x1c }, { 0x9b, 0xbe, 0x1d }, { 0x9e, 0xbe, 0x1e }, { 0xa0, 0xbe, 0x1f }, { 0xa3, 0xbf, 0x20 },
	{ 0xa5, 0xbf, 0x21 }, { 0xa8, 0xbf, 0x22 }, { 0xaa, 0xbf, 0x23 }, { 0xad, 0xbf, 0x24 }, { 0xaf, 0xc0, 0x25 }, { 0xb2, 0xc0, 0x27 }, { 0xb4, 0xc0, 0x28 }, { 0xb7, 0xc0, 0x29 },
	{ 0xb9, 0xc1, 0x2b }, { 0xbb, 0xc1, 0x2c }, { 0xbe, 0xc1, 0x2d }, { 0xc0, 0xc1, 0x2f }, { 0xc2, 0xc1, 0x30 }, { 0xc4, 0xc2, 0x32 }, { 0xc7, 0xc2, 0x33 }, { 0xc9, 0xc2, 0x34 },
	{ 0xcb, 0xc2, 0x36 }, { 0xcd, 0xc2, 0x37 }, { 0xcf, 0xc3, 0x39 }, { 0xd2, 0xc3, 0x3a }, { 0xd4, 0xc3, 0x3b }, { 0xd6, 0xc3, 0x3d }, { 0xd8, 0xc4, 0x3e }, { 0xda, 0xc4, 0x40 },
	{ 0xdc, 0xc4, 0x41 }, { 0xde, 0xc4, 0x42 }, { 0xe1, 0xc4, 0x44 }, { 0xe3, 0xc5, 0x45 }, { 0xe5, 0xc5, 0x46 }, { 0xe7, 0xc5, 0x48 }, { 0xe9, 0xc5, 0x49 }, { 0xeb, 0xc5, 0x4a },
	{ 0xed, 0xc6, 0x4c }, { 0xef, 0xc6, 0x4d }, { 0xf1, 0xc6, 0x4e }, { 0xf3, 0xc6, 0x50 }, { 0xf6, 0xc6, 0x51 }, { 0xf8, 0xc7, 0x52 }, { 0xfa, 0xc7, 0x53 }, { 0xfc, 0xc7, 0x53 },
	{ 0xfd, 0xc8, 0x51 }, { 0xfd, 0xc9, 0x50 }, { 0xfe, 0xca, 0x4f }, { 0xfe, 0xcc, 0x4e }, { 0xfe, 0xcd, 0x4d }, { 0xfe, 0xce, 0x4c }, { 0xfe, 0xd0, 0x4b }, { 0xfe, 0xd1, 0x4a },
	{ 0xfe, 0xd3, 0x49 }, { 0xfe, 0xd4, 0x48 }, { 0xfe, 0xd5, 0x47 }, { 0xfe, 0xd7, 0x46 }, { 0xfe, 0xd8, 0x45 }, { 0xfe, 0xda, 0x44 }, { 0xfe, 0xdb, 0x43 }, { 0xfe, 0xdc, 0x41 },
	{ 0xfe, 0xde, 0x40 }, { 0xfd, 0xdf, 0x3f }, { 0xfd, 0xe1, 0x3d }, { 0xfd, 0xe2, 0x3c }, { 0xfd, 0xe3, 0x3a }, { 0xfd, 0xe5, 0x38 }, { 0xfd, 0xe6, 0x37 }, { 0xfd, 0xe8, 0x35 },
	{ 0xfd, 0xe9, 0x33 }, { 0xfc, 0xeb, 0x31 }, { 0xfc, 0xec, 0x2e }, { 0xfc, 0xee, 0x2c }, { 0xfc, 0xef, 0x29 }, { 0xfc, 0xf1, 0x27 }, { 0xfb, 0xf2, 0x23 }, { 0xfb, 0xf4, 0x20 },
};

static const unsigned char colormap_jet[256][3] = {
	{ 0x00, 0x00, 0x7f }, { 0x00, 0x00, 0x83 }, { 0x00, 0x00, 0x87 }, { 0x00, 0x00, 0x8b }, { 0x00, 0x00, 0x8f }, { 0x00, 0x00, 0x93 }, { 0x00, 0x00, 0x97 }, { 0x00, 0x00, 0x9b },
	{ 0x00, 0x00, 0x9f }, { 0x00, 0x00, 0xa3 }, { 0x00, 0x00, 0xa7 }, { 0x00, 0x00, 0xab }, { 0x00, 0x00, 0xaf }, { 0x00, 0x00, 0xb3 }, { 0x00, 0x00, 0xb7 }, { 0x00, 0x00, 0xbb },
	{ 0x00, 0x00, 0xbf }, { 0x00, 0x00, 0xc3 }, { 0x00, 0x00, 0xc7 }, { 0x00, 0x00, 0xcb }, { 0x00, 0x00, 0xcf }, { 0x00, 0x00, 0xd3 }, { 0x00, 0x00, 0xd7 }, { 0x00, 0x00, 0xdb },
	{ 0x00, 0x00, 0xdf }, { 0x00, 0x00, 0xe3 }, { 0x00, 0x00, 0xe7 }, { 0x00, 0x00, 0xeb }, { 0x00, 0x00, 0xef }, { 0x00, 0x00, 0xf3 }, { 0x00, 0x00, 0xf7 }, { 0x00, 0x00, 0xfb },
	{ 0x00, 0x00, 0xff }, { 0x00, 0x04, 0xff }, { 0x00, 0x08, 0xff }, { 0x00, 0x0c, 0xff }, { 0x00, 0x10, 0xff }, { 0x00, 0x14, 0xff }, { 0x00, 0x18, 0xff }, { 0x00, 0x1c, 0xff },
	{ 0x00, 0x20, 0xff }, { 0x00, 0x24, 0xff }, { 0x00, 0x28, 0xff }, { 0x00, 0x2c, 0xff }, { 0x00, 0x30, 0xff }, { 0x00, 0x34, 0xff }, { 0x00, 0x38, 0xff }, { 0x00, 0x3c, 0xff },
	{ 0x00, 0x40, 0xff }, { 0x00, 0x44, 0xff }, { 0x00, 0x48, 0xff }, { 0x00, 0x4c, 0xff }, { 0x00, 0x50, 0xff }, { 0x00, 0x54, 0xff }, { 0x00, 0x58, 0xff }, { 0x00, 0x5c, 0xff },
	{ 0x00, 0x60, 0xff }, { 0x00, 0x64, 0xff }, { 0x00, 0x68, 0xff }, { 0x00, 0x6c, 0xff }, { 0x00, 0x70, 0xff }, { 0x00, 0x74, 0xff }, { 0x00, 0x78, 0xff }, { 0x00, 0x7c, 0xff },
	{ 0x00, 0x80, 0xff }, { 0x00, 0x84, 0xff }, { 0x00, 0x88, 0xff }, { 0x00, 0x8c, 0xff }, { 0x00, 0x90, 0xff }, { 0x00, 0x94, 0xff }, { 0x00, 0x98, 0xff }, { 0x00, 0x9c, 0xff },
	{ 0x00, 0xa0, 0xff }, { 0x00, 0xa4, 0xff }, { 0x00, 0xa8, 0xff }, { 0x00, 0xac, 0xff }, { 0x00, 0xb0, 0xff }, { 0x00, 0xb4, 0xff }, { 0x00, 0xb8, 0xff }, { 0x00, 0xbc, 0xff },
	{ 0x00, 0xc0, 0xff }, { 0x00, 0xc4, 0xff }, { 0x00, 0xc8, 0xff }, { 0x00, 0xcc, 0xff }, { 0x00, 0xd0, 0xff }, { 0x00, 0xd4, 0xff }, { 0x00, 0xd8, 0xff }, { 0x00, 0xdc, 0xff },
	{ 0x00, 0xe0, 0xff }, { 0x00, 0xe4, 0xff }, { 0x00, 0xe8, 0xff }, { 0x00, 0xec, 0xff }, { 0x00, 0xf0, 0xff }, { 0x00, 0xf4, 0xff }, { 0x00, 0xf8, 0xff }, { 0x00, 0xfc, 0xff },
	{ 0x01, 0xff, 0xfd }, { 0x05, 0xff, 0xf9 }, { 0x09, 0xff, 0xf5 }, { 0x0d, 0xff, 0xf1 }, { 0x11, 0xff, 0xed }, { 0x15, 0xff, 0xe9 }, { 0x19, 0xff, 0xe5 }, { 0x1d, 0xff, 0xe1 },
	{ 0x21, 0xff, 0xdd }, { 0x25, 0xff, 0xd9 }, { 0x29, 0xff, 0xd5 }, { 0x2d, 0xff, 0xd1 }, { 0x31, 0xff, 0xcd }, { 0x35, 0xff, 0xc9 }, { 0x39, 0xff, 0xc5 }, { 0x3d, 0xff, 0xc1 },
	{ 0x41, 0xff, 0xbd }, { 0x45, 0xff, 0xb9 }, { 0x49, 0xff, 0xb5 }, { 0x4d, 0xff, 0xb1 }, { 0x51, 0xff, 0xad }, { 0x55, 0xff, 0xa9 }, { 0x59, 0xff, 0xa5 }, { 0x5d, 0xff, 0xa1 },
	{ 0x61, 0xff, 0x9d }, { 0x65, 0xff, 0x99 }, { 0x69, 0xff, 0x95 }, { 0x6d, 0xff, 0x91 }, { 0x71, 0xff, 0x8d }, { 0x75, 0xff, 0x89 }, { 0x79, 0xff, 0x85 }, { 0x7d, 0xff, 0x81 },
	{ 0x81, 0xff, 0x7d }, { 0x85, 0xff, 0x79 }, { 0x89, 0xff, 0x75 }, { 0x8d, 0xff, 0x71 }, { 0x91, 0xff, 0x6d }, { 0x95, 0xff, 0x69 }, { 0x99, 0xff, 0x65 }, { 0x9d, 0xff, 0x61 },
	{ 0xa1, 0xff, 0x5d }, { 0xa5, 0xff, 0x59 }, { 0xa9, 0xff, 0x55 }, { 0xad, 0xff, 0x51 }, { 0xb1, 0xff, 0x4d }, { 0xb5, 0xff, 0x49 }, { 0xb9, 0xff, 0x45 }, { 0xbd, 0xff, 0x41 },
	{ 0xc1, 0xff, 0x3d }, { 0xc5, 0xff, 0x39 }, { 0xc9, 0xff, 0x35 }, { 0xcd, 0xff, 0x31 }, { 0xd1, 0xff, 0x2d }, { 0xd5, 0xff, 0x29 }, { 0xd9, 0xff, 0x25 }, { 0xdd, 0xff, 0x21 },
	{ 0xe1, 0xff, 0x1d }, { 0xe5, 0xff, 0x19 }, { 0xe9, 0xff, 0x15 }, { 0xed, 0xff, 0x11 }, { 0xf1, 0xff, 0x0d }, { 0xf5, 0xff, 0x09 }, { 0xf9, 0xff, 0x05 }, { 0xfd, 0xff, 0x01 },
	{ 0xff, 0xfc, 0x00 }, { 0xff, 0xf8, 0x00 }, { 0xff, 0xf4, 0x00 }, { 0xff, 0xf0, 0x00 }, { 0xff, 0xec, 0x00 }, { 0xff, 0xe8, 0x00 }, { 0xff, 0xe4, 0x00 }, { 0xff, 0xe0, 0x00 },
	{ 0xff, 0xdc, 0x00 }, { 0xff, 0xd8, 0x00 }, { 0xff, 0xd4, 0x00 }, { 0xff, 0xd0, 0x00 }, { 0xff, 0xcc, 0x00 }, { 0xff, 0xc8, 0x00 }, { 0xff, 0xc4, 0x00 }, { 0xff, 0xc0, 0x00 },
	{ 0xff, 0xbc, 0x00 }, { 0xff, 0xb8, 0x00 }, { 0xff, 0xb4, 0x00 }, { 0xff, 0xb0, 0x00 }, { 0xff, 0xac, 0x00 }, { 0xff, 0xa8, 0x00 }, { 0xff, 0xa4, 0x00 }, { 0xff, 0xa0, 0x00 },
	{ 0xff, 0x9c, 0x00 }, { 0xff, 0x98, 0x00 }, { 0xff, 0x94, 0x00 }, { 0xff, 0x90, 0x00 }, { 0xff, 0x8c, 0x00 }, { 0xff, 0x88, 0x00 }, { 0xff, 0x84, 0x00 }, { 0xff, 0x80, 0x00 },
	{ 0xff, 0x7c, 0x00 }, { 0xff, 0x78, 0x00 }, { 0xff, 0x74, 0x00 }, { 0xff, 0x70, 0x00 }, { 0xff, 0x6c, 0x00 }, { 0xff, 0x68, 0x00 }, { 0xff, 0x64, 0x00 }, { 0xff, 0x60, 0x00 },
	{ 0xff, 0x5c, 0x00 }, { 0xff, 0x58, 0x00 }, { 0xff, 0x54, 0x00 }, { 0xff, 0x50, 0x00 }, { 0xff, 0x4c, 0x00 }, { 0xff, 0x48, 0x00 }, { 0xff, 0x44, 0x00 }, { 0xff, 0x40, 0x00 },
	{ 0xff, 0x3c, 0x00 }, { 0xff, 0x38, 0x00 }, { 0xff, 0x34, 0x00 }, { 0xff, 0x30, 0x00 }, { 0xff, 0x2c, 0x00 }, { 0xff, 0x28, 0x00 }, { 0xff, 0x24, 0x00 }, { 0xff, 0x20, 0x00 },
	{ 0xff, 0x1c, 0x00 }, { 0xff, 0x18, 0x00 }, { 0xff, 0x14, 0x00 }, { 0xff, 0x10, 0x00 }, { 0xff, 0x0c, 0x00 }, { 0xff, 0x08, 0x00 }, { 0xff, 0x04, 0x00 }, { 0xff, 0x00, 0x00 },
	{ 0xfb, 0x00, 0x00 }, { 0xf7, 0x00, 0x00 }, { 0xf3, 0x00, 0x00 }, { 0xef, 0x00, 0x00 }, { 0xeb, 0x00, 0x00 }, { 0xe7, 0x00, 0x00 }, { 0xe3, 0x00, 0x00 }, { 0xdf, 0x00, 0x00 },
	{ 0xdb, 0x00, 0x00 }, { 0xd7, 0x00, 0x00 }, { 0xd3, 0x00, 0x00 }, { 0xcf, 0x00, 0x00 }, { 0xcb, 0x00, 0x00 }, { 0xc7, 0x00, 0x00 }, { 0xc3, 0x00, 0x00 }, { 0xbf, 0x00, 0x00 },
	{ 0xbb, 0x00, 0x00 }, { 0xb7, 0x00, 0x00 }, { 0xb3, 0x00, 0x00 }, { 0xaf, 0x00, 0x00 }, { 0xab, 0x00, 0x00 }, { 0xa7, 0x00, 0x00 }, { 0xa3, 0x00, 0x00 }, { 0x9f, 0x00, 0x00 },
	{ 0x9b, 0x00, 0x00 }, { 0x97, 0x00, 0x00 }, { 0x93, 0x00, 0x00 }, { 0x8f, 0x00, 0x00 }, { 0x8b, 0x00, 0x00 }, { 0x87, 0x00, 0x00 }, { 0x83, 0x00, 0x00 }, { 0x7f, 0x00, 0x00 },
};

static const unsigned char colormap_rainbow[256][3] = {
	{ 0x26, 0x00, 0x32 }, { 0x26, 0x00, 0x33 }, { 0x26, 0x00, 0x33 }, { 0x26, 0x00, 0x33 }, { 0x27, 0x00, 0x34 }, { 0x27, 0x00, 0x34 }, { 0x27, 0x00, 0x35 }, { 0x28, 0x00, 0x36 },
	{ 0x29, 0x00, 0x37 }, { 0x29, 0x00, 0x39 }, { 0x2a, 0x00, 0x3a }, { 0x2b, 0x00, 0x3c }, { 0x2c, 0x00, 0x3d }, { 0x2d, 0x00, 0x3f }, { 0x2e, 0x00, 0x41 }, { 0x2f, 0x00, 0x43 },
	{ 0x30, 0x00, 0x46 }, { 0x32, 0x00, 0x48 }, { 0x33, 0x00, 0x4b }, { 0x34, 0x00, 0x4d }, { 0x35, 0x00, 0x50 }, { 0x36, 0x00, 0x53 }, { 0x38, 0x00, 0x56 }, { 0x39, 0x00, 0x59 },
	{ 0x3a, 0x00, 0x5c }, { 0x3b, 0x00, 0x60 }, { 0x3c, 0x00, 0x63 }, { 0x3d, 0x00, 0x67 }, { 0x3e, 0x00, 0x6a }, { 0x3f, 0x00, 0x6e }, { 0x40, 0x00, 0x72 }, { 0x41, 0x00, 0x75 },
	{ 0x41, 0x00, 0x79 }, { 0x42, 0x00, 0x7d }, { 0x42, 0x00, 0x81 }, { 0x42, 0x00, 0x85 }, { 0x42, 0x00, 0x89 }, { 0x42, 0x00, 0x8d }, { 0x42, 0x00, 0x91 }, { 0x41, 0x00, 0x96 },
	{ 0x41, 0x00, 0x9a }, { 0x40, 0x00, 0x9e }, { 0x3f, 0x00, 0xa2 }, { 0x3e, 0x00, 0xa6 }, { 0x3c, 0x00, 0xaa }, { 0x3b, 0x00, 0xae }, { 0x39, 0x00, 0xb3 }, { 0x37, 0x00, 0xb7 },
	{ 0x34, 0x00, 0xbb }, { 0x32, 0x00, 0xbf }, { 0x2f, 0x00, 0xc3 }, { 0x2c, 0x00, 0xc6 }, { 0x29, 0x00, 0xca }, { 0x26, 0x00, 0xce }, { 0x22, 0x00, 0xd2 }, { 0x1e, 0x00, 0xd5 },
	{ 0x1a, 0x00, 0xd9 }, { 0x15, 0x00, 0xdc }, { 0x11, 0x00, 0xdf }, { 0x0c, 0x00, 0xe2 }, { 0x07, 0x00, 0xe5 }, { 0x02, 0x00, 0xe8 }, { 0x00, 0x03, 0xeb }, { 0x00, 0x08, 0xed },
	{ 0x00, 0x0e, 0xf0 }, { 0x00, 0x14, 0xf2 }, { 0x00, 0x1a, 0xf4 }, { 0x00, 0x21, 0xf6 }, { 0x00, 0x27, 0xf7 }, { 0x00, 0x2e, 0xf9 }, { 0x00, 0x34, 0xfa }, { 0x00, 0x3b, 0xfb },
	{ 0x00, 0x42, 0xfc }, { 0x00, 0x49, 0xfd }, { 0x00, 0x50, 0xfd }, { 0x00, 0x56, 0xfd }, { 0x00, 0x5d, 0xfd }, { 0x00, 0x64, 0xfd }, { 0x00, 0x6b, 0xfd }, { 0x00, 0x72, 0xfd },
	{ 0x00, 0x79, 0xfd }, { 0x00, 0x80, 0xfd }, { 0x00, 0x88, 0xfc }, { 0x00, 0x8f, 0xfc }, { 0x00, 0x96, 0xfc }, { 0x00, 0x9d, 0xfc }, { 0x00, 0xa5, 0xfc }, { 0x00, 0xac, 0xfc },
	{ 0x00, 0xb4, 0xfc }, { 0x00, 0xbb, 0xfc }, { 0x00, 0xc2, 0xfb }, { 0x00, 0xca, 0xfb }, { 0x00, 0xd2, 0xfb }, { 0x00, 0xd9, 0xfb }, { 0x00, 0xe1, 0xfa }, { 0x00, 0xe8, 0xfa },
	{ 0x00, 0xf0, 0xfa }, { 0x00, 0xf7, 0xfa }, { 0x00, 0xf9, 0xf4 }, { 0x00, 0xf9, 0xeb }, { 0x00, 0xf8, 0xe3 }, { 0x00, 0xf8, 0xdb }, { 0x00, 0xf7, 0xd2 }, { 0x00, 0xf7, 0xca },
	{ 0x00, 0xf6, 0xc1 }, { 0x00, 0xf5, 0xb9 }, { 0x00, 0xf5, 0xb0 }, { 0x00, 0xf4, 0xa7 }, { 0x00, 0xf3, 0x9f }, { 0x00, 0xf1, 0x96 }, { 0x00, 0xf0, 0x8d }, { 0x00, 0xee, 0x84 },
	{ 0x00, 0xed, 0x7b }, { 0x00, 0xeb, 0x72 }, { 0x00, 0xe8, 0x69 }, { 0x00, 0xe5, 0x60 }, { 0x00, 0xe2, 0x57 }, { 0x00, 0xde, 0x4e }, { 0x00, 0xd9, 0x45 }, { 0x00, 0xd4, 0x3d },
	{ 0x00, 0xce, 0x34 }, { 0x00, 0xc6, 0x2b }, { 0x00, 0xbe, 0x23 }, { 0x00, 0xb5, 0x1b }, { 0x00, 0xac, 0x14 }, { 0x00, 0xa3, 0x0d }, { 0x00, 0x9d, 0x07 }, { 0x00, 0x99, 0x02 },
	{ 0x02, 0x99, 0x00 }, { 0x07, 0x9d, 0x00 }, { 0x0d, 0xa3, 0x00 }, { 0x14, 0xac, 0x00 }, { 0x1b, 0xb5, 0x00 }, { 0x23, 0xbe, 0x00 }, { 0x2b, 0xc6, 0x00 }, { 0x34, 0xce, 0x00 },
	{ 0x3d, 0xd4, 0x00 }, { 0x45, 0xd9, 0x00 }, { 0x4e, 0xde, 0x00 }, { 0x57, 0xe2, 0x00 }, { 0x60, 0xe5, 0x00 }, { 0x69, 0xe8, 0x00 }, { 0x72, 0xeb, 0x00 }, { 0x7b, 0xed, 0x00 },
	{ 0x84, 0xee, 0x00 }, { 0x8d, 0xf0, 0x00 }, { 0x96, 0xf1, 0x00 }, { 0x9f, 0xf3, 0x00 }, { 0xa7, 0xf4, 0x00 }, { 0xb0, 0xf5, 0x00 }, { 0xb9, 0xf5, 0x00 }, { 0xc1, 0xf6, 0x00 },
	{ 0xca, 0xf7, 0x00 }, { 0xd2, 0xf7, 0x00 }, { 0xdb, 0xf8, 0x00 }, { 0xe3, 0xf8, 0x00 }, { 0xeb, 0xf9, 0x00 }, { 0xf4, 0xf9, 0x00 }, { 0xfa, 0xf7, 0x00 }, { 0xfa, 0xf0, 0x00 },
	{ 0xfa, 0xe8, 0x00 }, { 0xfa, 0xe1, 0x00 }, { 0xfb, 0xd9, 0x00 }, { 0xfb, 0xd2, 0x00 }, { 0xfb, 0xca, 0x00 }, { 0xfb, 0xc2, 0x00 }, { 0xfc, 0xbb, 0x00 }, { 0xfc, 0xb4, 0x00 },
	{ 0xfc, 0xac, 0x00 }, { 0xfc, 0xa5, 0x00 }, { 0xfc, 0x9d, 0x00 }, { 0xfc, 0x96, 0x00 }, { 0xfc, 0x8f, 0x00 }, { 0xfc, 0x88, 0x00 }, { 0xfd, 0x80, 0x00 }, { 0xfd, 0x79, 0x00 },
	{ 0xfd, 0x72, 0x00 }, { 0xfd, 0x6b, 0x00 }, { 0xfd, 0x64, 0x00 }, { 0xfd, 0x5d, 0x00 }, { 0xfd, 0x56, 0x00 }, { 0xfd, 0x50, 0x00 }, { 0xfd, 0x49, 0x00 }, { 0xfc, 0x42, 0x00 },
	{ 0xfb, 0x3b, 0x00 }, { 0xfa, 0x34, 0x00 }, { 0xf9, 0x2e, 0x00 }, { 0xf7, 0x27, 0x00 }, { 0xf6, 0x21, 0x00 }, { 0xf4, 0x1a, 0x00 }, { 0xf2, 0x14, 0x00 }, { 0xf0, 0x0e, 0x00 },
	{ 0xed, 0x08, 0x00 }, { 0xeb, 0x03, 0x00 }, { 0xe8, 0x00, 0x02 }, { 0xe5, 0x00, 0x07 }, { 0xe2, 0x00, 0x0c }, { 0xdf, 0x00, 0x11 }, { 0xdc, 0x00, 0x15 }, { 0xd9, 0x00, 0x1a },
	{ 0xd5, 0x00, 0x1e }, { 0xd2, 0x00, 0x22 }, { 0xce, 0x00, 0x26 }, { 0xca, 0x00, 0x29 }, { 0xc6, 0x00, 0x2c }, { 0xc3, 0x00, 0x2f }, { 0xbf, 0x00, 0x32 }, { 0xbb, 0x00, 0x34 },
	{ 0xb7, 0x00, 0x37 }, { 0xb3, 0x00, 0x39 }, { 0xae, 0x00, 0x3b }, { 0xaa, 0x00, 0x3c }, { 0xa6, 0x00, 0x3e }, { 0xa2, 0x00, 0x3f }, { 0x9e, 0x00, 0x40 }, { 0x9a, 0x00, 0x41 },
	{ 0x96, 0x00, 0x41 }, { 0x91, 0x00, 0x42 }, { 0x8d, 0x00, 0x42 }, { 0x89, 0x00, 0x42 }, { 0x85, 0x00, 0x42 }, { 0x81, 0x00, 0x42 }, { 0x7d, 0x00, 0x42 }, { 0x79, 0x00, 0x41 },
	{ 0x75, 0x00, 0x41 }, { 0x72, 0x00, 0x40 }, { 0x6e, 0x00, 0x3f }, { 0x6a, 0x00, 0x3e }, { 0x67, 0x00, 0x3d }, { 0x63, 0x00, 0x3c }, { 0x60, 0x00, 0x3b }, { 0x5c, 0x00, 0x3a },
	{ 0x59, 0x00, 0x39 }, { 0x56, 0x00, 0x38 }, { 0x53, 0x00, 0x36 }, { 0x50, 0x00, 0x35 }, { 0x4d, 0x00, 0x34 }, { 0x4b, 0x00, 0x33 }, { 0x48, 0x00, 0x32 }, { 0x46, 0x00, 0x30 },
	{ 0x43, 0x00, 0x2f }, { 0x41, 0x00, 0x2e }, { 0x3f, 0x00, 0x2d }, { 0x3d, 0x00, 0x2c }, { 0x3c, 0x00, 0x2b }, { 0x3a, 0x00, 0x2a }, { 0x39, 0x00, 0x29 }, { 0x37, 0x00, 0x29 },
	{ 0x36, 0x00, 0x28 }, { 0x35, 0x00, 0x27 }, { 0x34, 0x00, 0x27 }, { 0x34, 0x00, 0x27 }, { 0x33, 0x00, 0x26 }, { 0x33, 0x00, 0x26 }, { 0x33, 0x00, 0x26 }, { 0x32, 0x00, 0x26 },
};

void render_default_filter_colorize(struct surface_t * s, const char * type)
{
	int width = surface_get_width(s);
	int height = surface_get_height(s);
	int stride = surface_get_stride(s);
	unsigned char * p, * q = surface_get_pixels(s);
	const unsigned char (*cm)[3];
	unsigned char r, g, b;
	int x, y;

	switch(shash(type))
	{
	case 0x143c974a: /* "parula" */
		cm = colormap_parula;
		break;
	case 0x0b888348: /* "jet" */
		cm = colormap_jet;
		break;
	case 0x351d1e97: /* "rainbow" */
		cm = colormap_rainbow;
		break;
	default:
		cm = colormap_parula;
		break;
	}
	for(y = 0; y < height; y++, q += stride)
	{
		for(x = 0, p = q; x < width; x++, p += 4)
		{
			if(p[3] != 0)
			{
				if(p[3] == 255)
				{
					p[0] = cm[p[0]][0];
					p[1] = cm[p[1]][1];
					p[2] = cm[p[2]][2];
				}
				else
				{
					b = p[0] * 255 / p[3];
					g = p[1] * 255 / p[3];
					r = p[2] * 255 / p[3];
					p[0] = cm[b][0] * p[3] / 255;
					p[1] = cm[g][1] * p[3] / 255;
					p[2] = cm[r][2] * p[3] / 255;
				}
			}
		}
	}
}

void render_default_filter_hue(struct surface_t * s, int angle)
{
	float av = angle * M_PI / 180.0;
	float cv = cosf(av);
	float sv = sinf(av);
	int width = surface_get_width(s);
	int height = surface_get_height(s);
	int stride = surface_get_stride(s);
	unsigned char * p, * q = surface_get_pixels(s);
	int r, g, b;
	int tr, tg, tb;
	int x, y;
	int m[9];

	m[0] = (0.213 + cv * 0.787 - sv * 0.213) * 65536;
	m[1] = (0.715 - cv * 0.715 - sv * 0.715) * 65536;
	m[2] = (0.072 - cv * 0.072 + sv * 0.928) * 65536;
	m[3] = (0.213 - cv * 0.213 + sv * 0.143) * 65536;
	m[4] = (0.715 + cv * 0.285 + sv * 0.140) * 65536;
	m[5] = (0.072 - cv * 0.072 - sv * 0.283) * 65536;
	m[6] = (0.213 - cv * 0.213 - sv * 0.787) * 65536;
	m[7] = (0.715 - cv * 0.715 + sv * 0.715) * 65536;
	m[8] = (0.072 + cv * 0.928 + sv * 0.072) * 65536;
	for(y = 0; y < height; y++, q += stride)
	{
		for(x = 0, p = q; x < width; x++, p += 4)
		{
			b = p[0];
			g = p[1];
			r = p[2];
			tb = (m[6] * r + m[7] * g + m[8] * b) >> 16;
			tg = (m[3] * r + m[4] * g + m[5] * b) >> 16;
			tr = (m[0] * r + m[1] * g + m[2] * b) >> 16;
			p[0] = clamp(tb, 0, 255);
			p[1] = clamp(tg, 0, 255);
			p[2] = clamp(tr, 0, 255);
		}
	}
}

void render_default_filter_saturate(struct surface_t * s, int saturate)
{
	int k = clamp(saturate, -100, 100) / 100.0 * 128.0;
	int width = surface_get_width(s);
	int height = surface_get_height(s);
	int stride = surface_get_stride(s);
	unsigned char * p, * q = surface_get_pixels(s);
	int r, g, b, min, max;
	int alpha, delta, value, lv, sv;
	int x, y;

	for(y = 0; y < height; y++, q += stride)
	{
		for(x = 0, p = q; x < width; x++, p += 4)
		{
			b = p[0];
			g = p[1];
			r = p[2];
			min = min(min(r, g), b);
			max = max(max(r, g), b);
			delta = max - min;
			value = max + min;
			if(delta == 0)
				continue;
			lv = value >> 1;
			sv = lv < 128 ? (delta << 7) / value : (delta << 7) / (510 - value);
			if(k >= 0)
			{
				alpha = (k + sv >= 128) ? sv : 128 - k;
				if(alpha != 0)
					alpha = 128 * 128 / alpha - 128;
			}
			else
			{
				alpha = k;
			}
			r = r + ((r - lv) * alpha >> 7);
			g = g + ((g - lv) * alpha >> 7);
			b = b + ((b - lv) * alpha >> 7);
			p[0] = clamp(b, 0, 255);
			p[1] = clamp(g, 0, 255);
			p[2] = clamp(r, 0, 255);
		}
	}
}

void render_default_filter_brightness(struct surface_t * s, int brightness)
{
	int delta = clamp(brightness, -100, 100) / 100.0 * 255.0;
	int width = surface_get_width(s);
	int height = surface_get_height(s);
	int stride = surface_get_stride(s);
	unsigned char * p, * q = surface_get_pixels(s);
	int r, g, b;
	int tr, tg, tb;
	int x, y;

	for(y = 0; y < height; y++, q += stride)
	{
		for(x = 0, p = q; x < width; x++, p += 4)
		{
			b = p[0];
			g = p[1];
			r = p[2];
			tb = b + delta;
			tg = g + delta;
			tr = r + delta;
			p[0] = clamp(tb, 0, 255);
			p[1] = clamp(tg, 0, 255);
			p[2] = clamp(tr, 0, 255);
		}
	}
}

void render_default_filter_contrast(struct surface_t * s, int contrast)
{
	int k = clamp(contrast, -100, 100) / 100.0 * 128.0;
	int width = surface_get_width(s);
	int height = surface_get_height(s);
	int stride = surface_get_stride(s);
	unsigned char * p, * q = surface_get_pixels(s);
	int r, g, b;
	int tr, tg, tb;
	int x, y;

	for(y = 0; y < height; y++, q += stride)
	{
		for(x = 0, p = q; x < width; x++, p += 4)
		{
			b = p[0];
			g = p[1];
			r = p[2];
			tb = (b << 7) + (b - 128) * k;
			tg = (g << 7) + (g - 128) * k;
			tr = (r << 7) + (r - 128) * k;
			p[0] = clamp(tb, 0, 255 << 7) >> 7;
			p[1] = clamp(tg, 0, 255 << 7) >> 7;
			p[2] = clamp(tr, 0, 255 << 7) >> 7;
		}
	}
}

void render_default_filter_opacity(struct surface_t * s, int alpha)
{
	alpha = clamp(alpha, 0, 100) * 255 / 100;
	int width = surface_get_width(s);
	int height = surface_get_height(s);
	int stride = surface_get_stride(s);
	unsigned char * p, * q = surface_get_pixels(s);
	int x, y;
	switch(alpha)
	{
	case 0:
		memset(s->pixels, 0, s->pixlen);
		break;
	case 255:
		break;
	default:
		for(y = 0; y < height; y++, q += stride)
		{
			for(x = 0, p = q; x < width; x++, p += 4)
			{
				if(p[3] != 0)
				{
					p[0] = (p[0] * alpha) >> 8;
					p[1] = (p[1] * alpha) >> 8;
					p[2] = (p[2] * alpha) >> 8;
					p[3] = (p[3] * alpha) >> 8;
				}
			}
		}
		break;
	}
}

static inline void blurinner(unsigned char * p, int * zr, int * zg, int * zb, int * za, int alpha)
{
	int r, g, b;
	unsigned char a;

	b = p[0];
	g = p[1];
	r = p[2];
	a = p[3];

	*zb += (alpha * ((b << 7) - *zb)) >> 16;
	*zg += (alpha * ((g << 7) - *zg)) >> 16;
	*zr += (alpha * ((r << 7) - *zr)) >> 16;
	*za += (alpha * ((a << 7) - *za)) >> 16;

	p[0] = *zb >> 7;
	p[1] = *zg >> 7;
	p[2] = *zr >> 7;
	p[3] = *za >> 7;
}

static inline void blurrow(unsigned char * pixel, int width, int height, int channel, int line, int alpha)
{
	unsigned char * p = &(pixel[line * width * channel]);
	int zr, zg, zb, za;
	int i;

	zb = p[0] << 7;
	zg = p[1] << 7;
	zr = p[2] << 7;
	za = p[3] << 7;

	for(i = 0; i < width; i++)
		blurinner(&p[i * channel], &zr, &zg, &zb, &za, alpha);
	for(i = width - 2; i >= 0; i--)
		blurinner(&p[i * channel], &zr, &zg, &zb, &za, alpha);
}

static inline void blurcol(unsigned char * pixel, int width, int height, int channel, int x, int alpha)
{
	unsigned char * p = pixel;
	int zr, zg, zb, za;
	int i;

	p += x * channel;
	zb = p[0] << 7;
	zg = p[1] << 7;
	zr = p[2] << 7;
	za = p[3] << 7;

	for(i = width; i < (height - 1) * width; i += width)
		blurinner(&p[i * channel], &zr, &zg, &zb, &za, alpha);
	for(i = (height - 2) * width; i >= 0; i -= width)
		blurinner(&p[i * channel], &zr, &zg, &zb, &za, alpha);
}

static inline void expblur(unsigned char * pixel, int width, int height, int channel, int radius)
{
	int alpha = (int)((1 << 16) * (1.0 - expf(-2.3 / (radius + 1.0))));
	int row, col;

	for(row = 0; row < height; row++)
		blurrow(pixel, width, height, channel, row, alpha);
	for(col = 0; col < width; col++)
		blurcol(pixel, width, height, channel, col, alpha);
}

void render_default_filter_blur(struct surface_t * s, int radius)
{
	int width = surface_get_width(s);
	int height = surface_get_height(s);
	unsigned char * pixels = surface_get_pixels(s);

	if(radius > 0)
		expblur(pixels, width, height, 4, radius);
}
